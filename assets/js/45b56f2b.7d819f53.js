"use strict";(self.webpackChunkfmodel=self.webpackChunkfmodel||[]).push([[3113],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function d(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),l=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=l(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=d(e,["components","mdxType","originalType","parentName"]),c=l(a),g=r,u=c["".concat(s,".").concat(g)]||c[g]||m[g]||o;return a?n.createElement(u,i(i({ref:t},p),{},{components:a})):n.createElement(u,i({ref:t},p))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=g;var d={};for(var s in t)hasOwnProperty.call(t,s)&&(d[s]=t[s]);d.originalType=e,d[c]="string"==typeof e?e:r,i[1]=d;for(var l=2;l<o;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}g.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(7294),r=a(6010);const o={tabItem:"tabItem_Ymn6"};function i(e){let{children:t,hidden:a,className:i}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(o.tabItem,i),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>E});var n=a(7462),r=a(7294),o=a(6010),i=a(2466),d=a(6550),s=a(1980),l=a(7392),p=a(12);function c(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function m(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??c(a);return function(e){const t=(0,l.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function g(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function u(e){let{queryString:t=!1,groupId:a}=e;const n=(0,d.k6)(),o=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,s._X)(o),(0,r.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(n.location.search);t.set(o,e),n.replace({...n.location,search:t.toString()})}),[o,n])]}function v(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,o=m(e),[i,d]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!g({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:o}))),[s,l]=u({queryString:a,groupId:n}),[c,v]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,o]=(0,p.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&o.set(e)}),[a,o])]}({groupId:n}),y=(()=>{const e=s??c;return g({value:e,tabValues:o})?e:null})();(0,r.useLayoutEffect)((()=>{y&&d(y)}),[y]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!g({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);d(e),l(e),v(e)}),[l,v,o]),tabValues:o}}var y=a(2389);const h={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:t,block:a,selectedValue:d,selectValue:s,tabValues:l}=e;const p=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.o5)(),m=e=>{const t=e.currentTarget,a=p.indexOf(t),n=l[a].value;n!==d&&(c(t),s(n))},g=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const a=p.indexOf(e.currentTarget)+1;t=p[a]??p[0];break}case"ArrowLeft":{const a=p.indexOf(e.currentTarget)-1;t=p[a]??p[p.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":a},t)},l.map((e=>{let{value:t,label:a,attributes:i}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:d===t?0:-1,"aria-selected":d===t,key:t,ref:e=>p.push(e),onKeyDown:g,onClick:m},i,{className:(0,o.Z)("tabs__item",h.tabItem,i?.className,{"tabs__item--active":d===t})}),a??t)})))}function S(e){let{lazy:t,children:a,selectedValue:n}=e;const o=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function b(e){const t=v(e);return r.createElement("div",{className:(0,o.Z)("tabs-container",h.tabList)},r.createElement(f,(0,n.Z)({},e,t)),r.createElement(S,(0,n.Z)({},e,t)))}function E(e){const t=(0,y.Z)();return r.createElement(b,(0,n.Z)({key:String(t)},e))}},524:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>d,metadata:()=>l,toc:()=>c});var n=a(7462),r=(a(7294),a(3905)),o=a(4866),i=a(5162);const d={sidebar_position:2},s="Application",l={unversionedId:"application/application",id:"application/application",title:"Application",description:"The only responsibility of the application layer is to orchestrate the execution of the logic by",source:"@site/docs/application/application.md",sourceDirName:"application",slug:"/application/",permalink:"/fmodel/docs/application/",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Architecture",permalink:"/fmodel/docs/application/architecture"},next:{title:"Examples",permalink:"/fmodel/docs/application/example"}},p={},c=[{value:"Event-Sourced vs State-Stored",id:"event-sourced-vs-state-stored",level:2},{value:"Application modules",id:"application-modules",level:2}],m={toc:c},g="wrapper";function u(e){let{components:t,...d}=e;return(0,r.kt)(g,(0,n.Z)({},m,d,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"application"},"Application"),(0,r.kt)("p",null,"The only responsibility of the application layer is to orchestrate the execution of the logic by"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"loading the state from a repository"),(0,r.kt)("li",{parentName:"ul"},"execute logic by executing domain layer components"),(0,r.kt)("li",{parentName:"ul"},"store the new state")),(0,r.kt)("p",null,"Fmodel offers application interfaces/components which are actually composed out of repository interfaces/components (side effects) and core domain components (decision-making):"),(0,r.kt)("h2",{id:"event-sourced-vs-state-stored"},"Event-Sourced vs State-Stored"),(0,r.kt)(o.Z,{groupId:"system-type",queryString:"system-type",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"event-stored",label:"Event-Stored / Event-Sourced",mdxType:"TabItem"},(0,r.kt)("p",null,"Event-stored systems are split to command and view/query models, by default.\nThis is making a huge difference as we are not limited to use a single canonical model for writing and\nreading/presenting!"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"event-modeling-event-driven-systems",src:a(5557).Z,width:"5391",height:"3776"})),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Event-sourcing Aggregate")," is a formalization of the event-stored/event-sourced system (Command\nModel) ",(0,r.kt)("a",{parentName:"p",href:"/fmodel/docs/application/architecture#event-stored-or-state-stored-systems"},"mentioned previously"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"interface EventSourcingAggregate<C, S, E> : IDecider<C, S, E>, EventRepository<C, E>\ninterface EventSourcingOrchestratingAggregate<C, S, E> : IDecider<C, S, E>, EventRepository<C, E>, ISaga<E, C>\ninterface MaterializedView<S, E> : IView<S, E>, ViewStateRepository<E, S>\ninterface SagaManager<AR, A> : ISaga<AR, A>, ActionPublisher<A>\n")),(0,r.kt)("p",null,"Event-sourcing Aggregate is using/delegating a ",(0,r.kt)("inlineCode",{parentName:"p"},"Decider")," to handle commands and produce events. It belongs to the\nApplication layer. In order to\nhandle the command, aggregate needs to fetch the current state (represented as a list of events)\nvia ",(0,r.kt)("inlineCode",{parentName:"p"},"EventRepository.fetchEvents")," function, and then delegate the command to the decider which can produce new events as\na result. Produced events are then stored via ",(0,r.kt)("inlineCode",{parentName:"p"},"EventRepository.save")," suspending function."),(0,r.kt)("p",null,"The Delegation pattern has proven to be a good alternative to ",(0,r.kt)("inlineCode",{parentName:"p"},"implementation inheritance"),", and Kotlin supports it\nnatively requiring zero boilerplate code.\n",(0,r.kt)("inlineCode",{parentName:"p"},"eventSourcingAggregate")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"eventSourcingOrchestratingAggregate")," functions, provided by the Fmodel, are good example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun <C, S, E> eventSourcingAggregate(\n    decider: IDecider<C, S, E>,\n    eventRepository: EventRepository<C, E>\n): EventSourcingAggregate<C, S, E> =\n    object :\n        EventSourcingAggregate<C, S, E>,\n        EventRepository<C, E> by eventRepository,\n        IDecider<C, S, E> by decider {}\n\nfun <C, S, E> eventSourcingOrchestratingAggregate(\n   decider: IDecider<C, S, E>,\n   eventRepository: EventRepository<C, E>,\n   saga: ISaga<E, C>\n): EventSourcingOrchestratingAggregate<C, S, E> =\n   object : EventSourcingOrchestratingAggregate<C, S, E>,\n      EventRepository<C, E> by eventRepository,\n      IDecider<C, S, E> by decider,\n      ISaga<E, C> by saga {}\n")),(0,r.kt)(o.Z,{groupId:"style",queryString:"style",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"monolith",label:"monolith",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Example of a monolith scenario, in which Order and Restaurant deciders\nare ",(0,r.kt)("a",{parentName:"em",href:"/fmodel/docs/domain/aggregating-the-behaviour?component-type=decider"},"combined/aggregated")," in one big decider and then\nwrapped by one aggregate component:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"/**\n * A convenient type alias for Decider<OrderCommand?, Order?, OrderEvent?>\n */\ntypealias OrderDecider = Decider<OrderCommand?, Order?, OrderEvent?>\n\n/**\n * A convenient type alias for Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n */\ntypealias RestaurantDecider = Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n\n/**\n * A convenient type alias for EventRepository<Command?, Event?>\n *     \n * notice that OrderCommand and RestaurantCommand are extending `sealed` Command,\n * and that OrderEvent and RestaurantEvent are extending `sealed` Event\n */\ntypealias AggregateEventRepository = EventRepository<Command?, Event?>\n\n\nval aggregate = eventSourcingAggregate(orderDecider combine restaurantDecider, aggregateEventRepository)\n\n\n/**\n * Start handling all your commands!\n */\naggregate.handle(command)\n"))),(0,r.kt)(i.Z,{value:"monolith-orchestrated",label:"monolith orchestrated",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Example of a monolith scenario, in which Order and Restaurant deciders\nare ",(0,r.kt)("a",{parentName:"em",href:"/fmodel/docs/domain/aggregating-the-behaviour?component-type=decider"},"combined/aggregated")," in one big decider, additionally Order and Restaurant sagas are ",(0,r.kt)("a",{parentName:"em",href:"/fmodel/docs/domain/aggregating-the-behaviour?component-type=saga"},"combined")," into one orchestrating saga.\nDecider and Saga are then wrapped by one aggregate component. Saga is responsible to integrate deciders internally, and enable event of one decider to trigger command of another, automatically")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Events produced by both deciders belong to the same transaction, and they are immediately consistent.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"/**\n * A convenient type alias for Decider<OrderCommand?, Order?, OrderEvent?>\n */\ntypealias OrderDecider = Decider<OrderCommand?, Order?, OrderEvent?>\n\n/**\n * A convenient type alias for Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n */\ntypealias RestaurantDecider = Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n\n/**\n * A convenient type alias for Saga<RestaurantEvent?, OrderCommand?>\n */\ntypealias OrderSaga = Saga<RestaurantEvent?, OrderCommand>\n\n/**\n * A convenient type alias for Saga<OrderEvent?, RestaurantCommand>\n */\ntypealias RestaurantSaga = Saga<OrderEvent?, RestaurantCommand>\n\n/**\n * A convenient type alias for EventRepository<Command?, Event?>\n *     \n * notice that OrderCommand and RestaurantCommand are extending `sealed` Command,\n * and that OrderEvent and RestaurantEvent are extending `sealed` Event\n */\ntypealias AggregateEventRepository = EventRepository<Command?, Event?>\n\n\nval aggregate = eventSourcingOrchestratingAggregate(orderDecider combine restaurantDecider, aggregateEventRepository, orderSaga combine restaurantSaga)\n\n\n/**\n * Start handling all your commands!\n */\naggregate.handle(command)\n"))),(0,r.kt)(i.Z,{value:"distributed",label:"distributed",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Example of a distributed scenario, in which Order and Restaurant deciders are wrapped by independent aggregate\ncomponents:")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"In distributed scenario, all aggregate components could be deployed as independent applications")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"/**\n * A convenient type alias for Decider<OrderCommand?, Order?, OrderEvent?>\n */\ntypealias OrderDecider = Decider<OrderCommand?, Order?, OrderEvent?>\n\n/**\n * A convenient type alias for Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n */\ntypealias RestaurantDecider = Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n\n/**\n * A convenient type alias for EventRepository<OrderCommand?, OrderEvent?>\n */\ntypealias OrderAggregateEventRepository = EventRepository<OrderCommand?, OrderEvent?>\n\n/**\n * A convenient type alias for EventRepository<RestaurantCommand?, RestaurantEvent?>\n */\ntypealias RestaurantAggregateEventRepository = EventRepository<RestaurantCommand?, RestaurantEvent?>\n\nval orderAggregate = eventSourcingAggregate(orderDecider, orderAggregateEventRepository)\nval restaurantAggregate = eventSourcingAggregate(restaurantDecider, restaurantAggregateEventRepository)\n\n\n/**\n * Start handling your Order commands!\n */\norderAggregate.handle(orderCommand)\n\n/**\n * Start handling your Restaurant commands!\n */\nrestaurantAggregate.handle(restaurantCommand)\n"))),(0,r.kt)(i.Z,{value:"distributed-orchestrated",label:"distributed orchestrated",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Example of a distributed scenario, in which Order and Restaurant deciders are wrapped by independent aggregate\ncomponents, and Order and Restaurant sagas are combined into one Saga and wrapped by unique Saga Manager:")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"In distributed scenario, all aggregate and saga manager component(s) could be deployed as independent applications, communicating over the wire."),(0,r.kt)("p",{parentName:"admonition"},"In this scenario we have three components on the application layer that should communicate to each other over the wire:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"orderAggregate (app1)"),(0,r.kt)("li",{parentName:"ul"},"restaurantAggregate (app2)"),(0,r.kt)("li",{parentName:"ul"},"orchestratedSagaManager (app3)")),(0,r.kt)("p",{parentName:"admonition"},"The combined (orchestrating) ",(0,r.kt)("inlineCode",{parentName:"p"},"orchestratedSagaManager")," will react on events (",(0,r.kt)("strong",{parentName:"p"},"over the wire"),") produced by both aggregates and send commands (",(0,r.kt)("strong",{parentName:"p"},"over the wire"),") to these aggregates. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"/**\n * A convenient type alias for Decider<OrderCommand?, Order?, OrderEvent?>\n */\ntypealias OrderDecider = Decider<OrderCommand?, Order?, OrderEvent?>\n\n/**\n * A convenient type alias for Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n */\ntypealias RestaurantDecider = Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n\n/**\n * A convenient type alias for Saga<RestaurantEvent?, OrderCommand?>\n */\ntypealias OrderSaga = Saga<RestaurantEvent?, OrderCommand>\n\n/**\n * A convenient type alias for Saga<OrderEvent?, RestaurantCommand>\n */\ntypealias RestaurantSaga = Saga<OrderEvent?, RestaurantCommand>\n\n/**\n * A convenient type alias for EventRepository<OrderCommand?, OrderEvent?>\n */\ntypealias OrderAggregateEventRepository = EventRepository<OrderCommand?, OrderEvent?>\n\n/**\n * A convenient type alias for EventRepository<RestaurantCommand?, RestaurantEvent?>\n */\ntypealias RestaurantAggregateEventRepository = EventRepository<RestaurantCommand?, RestaurantEvent?>\n\n/**\n * A convenient type alias for ActionPublisher<Command?>\n */\ntypealias OrchestratingSagaManagerPublisher = ActionPublisher<Command?>\n\nval orderAggregate = eventSourcingAggregate(orderDecider, orderAggregateEventRepository)\nval restaurantAggregate = eventSourcingAggregate(restaurantDecider, restaurantAggregateEventRepository)\nval orchestratedSagaManager = sagaManager(orderSaga combine restaurantSaga, actionPublisher)\n\n\n/**\n * Start handling your Order commands!\n */\norderAggregate.handle(orderCommand)\n\n/**\n * Start handling your Restaurant commands!\n */\nrestaurantAggregate.handle(restaurantCommand)\n\n/**\n * Additionally, orchestratedSagaManager is reacting on events from one aggregate and publishes command to the other.\n */\nval someFlowOfEventsComingViaKafkaOrDB: Flow<Event>\nsomeFlowOfEventsComingViaKafkaOrDB.publishTo(orchestratedSagaManager).collect {...}\n"))),(0,r.kt)(i.Z,{value:"distributed-choreography",label:"distributed choreography",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Example of a distributed scenario, in which Order and Restaurant deciders are wrapped by independent aggregate\ncomponents, and Order and Restaurant sagas are wrapped by independent Saga managers:")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"In distributed scenario, all aggregate and corresponding saga manager component(s) could be deployed as independent applications, communicating over the wire."),(0,r.kt)("p",{parentName:"admonition"},"In this scenario we have four components on the application layer that should communicate to each other over the wire:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"orderAggregate (app1)"),(0,r.kt)("li",{parentName:"ul"},"orderSagaManager (app1)"),(0,r.kt)("li",{parentName:"ul"},"restaurantAggregate (app2)"),(0,r.kt)("li",{parentName:"ul"},"restaurantSagaManager (app2)")),(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"orderSagaManager / restaurantSagaManager")," will react on events (",(0,r.kt)("strong",{parentName:"p"},"over the wire"),") produced by aggregates and send commands (",(0,r.kt)("strong",{parentName:"p"},"locally"),") to the appropriate aggregate(s).")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"/**\n * A convenient type alias for Decider<OrderCommand?, Order?, OrderEvent?>\n */\ntypealias OrderDecider = Decider<OrderCommand?, Order?, OrderEvent?>\n\n/**\n * A convenient type alias for Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n */\ntypealias RestaurantDecider = Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n\n/**\n * A convenient type alias for Saga<RestaurantEvent?, OrderCommand?>\n */\ntypealias OrderSaga = Saga<RestaurantEvent?, OrderCommand>\n\n/**\n * A convenient type alias for Saga<OrderEvent?, RestaurantCommand>\n */\ntypealias RestaurantSaga = Saga<OrderEvent?, RestaurantCommand>\n\n/**\n * A convenient type alias for EventRepository<OrderCommand?, OrderEvent?>\n */\ntypealias OrderAggregateEventRepository = EventRepository<OrderCommand?, OrderEvent?>\n\n/**\n * A convenient type alias for EventRepository<RestaurantCommand?, RestaurantEvent?>\n */\ntypealias RestaurantAggregateEventRepository = EventRepository<RestaurantCommand?, RestaurantEvent?>\n\n/**\n * A convenient type alias for ActionPublisher<OrderCommand?>\n */\ntypealias OrderSagaManagerPublisher = ActionPublisher<OrderCommand?>\n\n/**\n * A convenient type alias for ActionPublisher<RestaurantCommand?>\n */\ntypealias RestaurantSagaManagerPublisher = ActionPublisher<RestaurantCommand?>\n\nval orderAggregate = eventSourcingAggregate(orderDecider, orderAggregateEventRepository)\nval restaurantAggregate = eventSourcingAggregate(restaurantDecider, restaurantAggregateEventRepository)\nval orderSagaManager = sagaManager(orderSaga, orderSagaManagerPublisher)\nval restaurantSagaManager = sagaManager(restaurantSaga, restaurantSagaManagerPublisher)\n\n\n/**\n * Start handling your Order commands!\n */\norderAggregate.handle(orderCommand)\n\n/**\n * Start handling your Restaurant commands!\n */\nrestaurantAggregate.handle(restaurantCommand)\n\n/**\n * Additionally, orderSagaManager is reacting on events from one `restaurantAggregate` and publishes command to the `orderAggregate`.\n */\nval someFlowOfRestaurantEventsComingViaKafkaOrDB: Flow<RestaurantEvent>\nsomeFlowOfRestaurantEventsComingViaKafkaOrDB.publishTo(orderSagaManager).collect {...}\n\n/**\n * Additionally, restaurantSagaManager is reacting on events from one `orderAggregate` and publishes command to the `restaurantAggregate`.\n */\nval someFlowOfOrderEventsComingViaKafkaOrDB: Flow<OrderEvent>\nsomeFlowOfOrderEventsComingViaKafkaOrDB.publishTo(restaurantSagaManager).collect {...}\n")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Materialized View")," is a formalization of the event-stored/event-sourced system (View\nModel) ",(0,r.kt)("a",{parentName:"p",href:"/fmodel/docs/application/architecture#event-stored-or-state-stored-systems"},"mentioned previously"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"interface MaterializedView<S, E> : IView<S, E>, ViewStateRepository<E, S>\n")),(0,r.kt)("p",null,"Materialized view is using/delegating a ",(0,r.kt)("inlineCode",{parentName:"p"},"View")," (domain component) to handle events of type ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," and to maintain a state\nof denormalized projection(s) as a result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"interface MaterializedView<S, E> : IView<S, E>, ViewStateRepository<E, S>\n\n// Notice the `delegation pattern`\nfun <S, E> materializedView(\n    view: IView<S, E>,\n    viewStateRepository: ViewStateRepository<E, S>,\n): MaterializedView<S, E> =\n    object : MaterializedView<S, E>, ViewStateRepository<E, S> by viewStateRepository, IView<S, E> by view {}\n\n")),(0,r.kt)(o.Z,{groupId:"style",queryString:"style",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"monolith",label:"monolith",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Example of a monolith scenario, in which Order and Restaurant views\nare ",(0,r.kt)("a",{parentName:"em",href:"/fmodel/docs/domain/aggregating-the-behaviour?component-type=view"},"combined")," in one big view and then wrapped by one\nmaterialized-view component:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"/**\n * A convenient type alias for View<OrderViewState?, OrderEvent?>\n */\ntypealias OrderView = View<OrderViewState?, OrderEvent?>\n\n/**\n * A convenient type alias for View<RestaurantViewState?, RestaurantEvent?>\n */\ntypealias RestaurantView = View<RestaurantViewState?, RestaurantEvent?>\n\n/**\n * A convenient type alias for ViewStateRepository<OrderEvent?, Pair<OrderViewState?, RestaurantViewState?>>\n */\ntypealias MaterializedViewStateRepository = ViewStateRepository<Event?, Pair<OrderViewState?, RestaurantViewState?>>\n\n\nval materializedView = materializedView(orderView combine restaurantView, materializedViewStateRepository)\n\n\n/**\n * Start handling all your events, and projecting them into denormalized state which is adequate for querying.\n */\nmaterializedView.handle(event)\n"))),(0,r.kt)(i.Z,{value:"distributed",label:"distributed",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Example of a distributed scenario, in which Order and Restaurant views are wrapped by independent materialized-view\ncomponents:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"/**\n * A convenient type alias for View<OrderViewState?, OrderEvent?>\n */\ntypealias OrderView = View<OrderViewState?, OrderEvent?>\n\n/**\n * A convenient type alias for View<RestaurantViewState?, RestaurantEvent?>\n */\ntypealias RestaurantView = View<RestaurantViewState?, RestaurantEvent?>\n\n/**\n * A convenient type alias for ViewStateRepository<OrderEvent?, OrderViewState?>\n */\ntypealias OrderMaterializedViewStateRepository = ViewStateRepository<OrderEvent?, OrderViewState?>\n\n/**\n * A convenient type alias for ViewStateRepository<RestaurantEvent?, RestaurantViewState?>\n */\ntypealias RestaurantMaterializedViewStateRepository = ViewStateRepository<RestaurantEvent?, RestaurantViewState?>\n\nval orderMaterializedView = materializedView(orderView, orderMaterializedViewStateRepository)\nval restaurantMaterializedView = materializedView(restaurantView, restaurantMaterializedViewStateRepository)\n\n\n/**\n * Start handling your Order events, and projecting them into denormalized state which is adequate for querying.\n */\norderMaterializedView.handle(orderEvent)\n\n/**\n * Start handling your Restaurant events, and projecting them into denormalized state which is adequate for querying.\n */\nrestaurantMaterializedView.handle(restauranEvent)\n"))))),(0,r.kt)(i.Z,{value:"state-stored",label:"State-Stored",mdxType:"TabItem"},(0,r.kt)("p",null,"State-stored systems are using single canonical model for writing and reading/presenting, by default."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"event-modeling-traditional-systems",src:a(6567).Z,width:"5480",height:"5461"})),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"State-stored Aggregate")," is a formalization of the state-stored\nsystem ",(0,r.kt)("a",{parentName:"p",href:"/fmodel/docs/application/architecture#event-stored-or-state-stored-systems"},"mentioned previously"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"interface StateStoredAggregate<C, S, E> : IDecider<C, S, E>, StateRepository<C, S>\ninterface StateStoredOrchestratingAggregate<C, S, E> : IDecider<C, S, E>, StateRepository<C, S>, ISaga<E, C>\n\n")),(0,r.kt)("p",null,"State-stored Aggregate is using/delegating a ",(0,r.kt)("inlineCode",{parentName:"p"},"Decider")," to handle commands and produce new state. It belongs to the\nApplication layer. In order to\nhandle the command, aggregate needs to fetch the current state via ",(0,r.kt)("inlineCode",{parentName:"p"},"StateRepository.fetchState")," function first, and then\ndelegate the command to the decider which can produce new state as a result. New state is then stored\nvia ",(0,r.kt)("inlineCode",{parentName:"p"},"StateRepository.save")," suspending function."),(0,r.kt)("p",null,"The Delegation pattern has proven to be a good alternative to ",(0,r.kt)("inlineCode",{parentName:"p"},"implementation inheritance"),", and Kotlin supports it\nnatively requiring zero boilerplate code. ",(0,r.kt)("inlineCode",{parentName:"p"},"stateStoredAggregate")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"stateStoredOrchestratingAggregate")," functions are good example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun <C, S, E> stateStoredAggregate(\n    decider: IDecider<C, S, E>,\n    stateRepository: StateRepository<C, S>\n): StateStoredAggregate<C, S, E> =\n    object :\n        StateStoredAggregate<C, S, E>,\n        StateRepository<C, S> by stateRepository,\n        IDecider<C, S, E> by decider {}\n\nfun <C, S, E> stateStoredOrchestratingAggregate(\n   decider: IDecider<C, S, E>,\n   stateRepository: StateRepository<C, S>,\n   saga: ISaga<E, C>\n): StateStoredOrchestratingAggregate<C, S, E> =\n   object : StateStoredOrchestratingAggregate<C, S, E>,\n      StateRepository<C, S> by stateRepository,\n      IDecider<C, S, E> by decider,\n      ISaga<E, C> by saga {}\n")),(0,r.kt)(o.Z,{groupId:"style",queryString:"style",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"monolith",label:"monolith",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Example of a monolith scenario, in which Order and Restaurant deciders\nare ",(0,r.kt)("a",{parentName:"em",href:"/fmodel/docs/domain/aggregating-the-behaviour?component-type=decider"},"combined/aggregated")," in one big decider and then\nwrapped by one aggregate component:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"/**\n * A convenient type alias for Decider<OrderCommand?, Order?, OrderEvent?>\n */\ntypealias OrderDecider = Decider<OrderCommand?, Order?, OrderEvent?>\n\n/**\n * A convenient type alias for Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n */\ntypealias RestaurantDecider = Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n\n/**\n * A convenient type alias for StateRepository<Command?, Pair<Restaurant?,Order?>>\n */\ntypealias AggregateStateRepository = StateRepository<Command?, Pair<Restaurant?,Order?>>\n\n\nval aggregate = stateStoredAggregate(orderDecider combine restaurantDecider, aggregateStateRepository)\n\n/**\n * Start handling all your commands!\n */\naggregate.handle(orderCommand)\n"))),(0,r.kt)(i.Z,{value:"monolith-orchestrated",label:"monolith orchestrated",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Example of a monolith scenario, in which Order and Restaurant deciders\nare ",(0,r.kt)("a",{parentName:"em",href:"/fmodel/docs/domain/aggregating-the-behaviour?component-type=decider"},"combined/aggregated")," in one big decider, additionally Order and Restaurant sagas are ",(0,r.kt)("a",{parentName:"em",href:"/fmodel/docs/domain/aggregating-the-behaviour?component-type=saga"},"combined")," into one orchestrating saga.\nDecider and Saga are then wrapped by one aggregate component.\nSaga is responsible to integrate deciders internally, and enable event of one decider to trigger command of another, automatically")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"/**\n * A convenient type alias for Decider<OrderCommand?, Order?, OrderEvent?>\n */\ntypealias OrderDecider = Decider<OrderCommand?, Order?, OrderEvent?>\n\n/**\n * A convenient type alias for Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n */\ntypealias RestaurantDecider = Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n\n/**\n * A convenient type alias for Saga<RestaurantEvent?, OrderCommand?>\n */\ntypealias OrderSaga = Saga<RestaurantEvent?, OrderCommand>\n\n/**\n * A convenient type alias for Saga<OrderEvent?, RestaurantCommand>\n */\ntypealias RestaurantSaga = Saga<OrderEvent?, RestaurantCommand>\n\n/**\n * A convenient type alias for StateRepository<Command?, Pair<Restaurant?,Order?>>\n */\ntypealias AggregateStateRepository = StateRepository<Command?, Pair<Restaurant?,Order?>>\n\n\nval aggregate = stateStoredOrchestratingAggregate(orderDecider combine restaurantDecider, aggregateStateRepository, orderSaga combine restaurantSaga)\n\n/**\n * Start handling all your commands!\n */\naggregate.handle(orderCommand)\n"))),(0,r.kt)(i.Z,{value:"distributed",label:"distributed",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Example of a distributed scenario, in which Order and Restaurant deciders are wrapped by independent aggregate\ncomponents:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"/**\n * A convenient type alias for Decider<OrderCommand?, Order?, OrderEvent?>\n */\ntypealias OrderDecider = Decider<OrderCommand?, Order?, OrderEvent?>\n\n/**\n * A convenient type alias for Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n */\ntypealias RestaurantDecider = Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n\n/**\n * A convenient type alias for StateRepository<OrderCommand?, Order?>\n */\ntypealias OrderAggregateStateRepository = StateRepository<OrderCommand?, Order?>\n\n/**\n * A convenient type alias for StateRepository<RestaurantCommand?, Restaurant?>\n */\ntypealias RestaurantAggregateStateRepository = StateRepository<RestaurantCommand?, Restaurant?>\n\nval orderAggregate = stateStoredAggregate(orderDecider, orderAggregateStateRepository)\nval restaurantAggregate = stateStoredAggregate(restaurantDecider, restaurantAggregateStateRepository)\n\n/**\n * Start handling your commands of type OrderCommand!\n */\norderAggregate.handle(orderCommand)\n\n/**\n * Start handling your commands of type RestaurantCommand!\n */\nrestaurantAggregate.handle(restaurantCommand)\n")))))),(0,r.kt)("h2",{id:"application-modules"},"Application modules"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"application")," modules are organized in hierarchy:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"application")," - ",(0,r.kt)("strong",{parentName:"li"},"base module")," is declaring all application interfaces: aggregate, materialized-view, saga-manager."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extensions")," - ",(0,r.kt)("strong",{parentName:"li"},"extension modules")," are extending the base module by providing concrete implementation of the ",(0,r.kt)("inlineCode",{parentName:"li"},"handle")," method as an extension function(s).",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"application-vanilla")," - is using plain/vanilla Kotlin to implement the application layer in order to load the state, orchestrate the execution of the logic and save new state."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"application-arrow")," - is using ",(0,r.kt)("a",{parentName:"li",href:"https://arrow-kt.io/"},"Arrow")," and Kotlin to implement the application layer in order to load the state, orchestrate the execution of the logic and save new state - providing structured, predictable and efficient handling of errors (using ",(0,r.kt)("inlineCode",{parentName:"li"},"Either"),").")))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The libraries are non-intrusive, and you can select any flavor, choose both (vanilla and/or arrow) or make your own extension."),(0,r.kt)("p",{parentName:"admonition"},"You can use only domain library and model the orchestration (application library) on your own.")),(0,r.kt)("p",null,"An example (taken from FModel ",(0,r.kt)("inlineCode",{parentName:"p"},"application-vanilla")," library):"),(0,r.kt)(o.Z,{groupId:"system-type",queryString:"system-type",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"event-stored",label:"Event-Stored / Event-Sourced",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun <C, S, E> EventSourcingAggregate<C, S, E>.handle(command: C): Flow<E> =\n   command\n      .fetchEvents()\n      .computeNewEvents(command)\n      .save()\n"))),(0,r.kt)(i.Z,{value:"state-stored",label:"State-Stored",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun <C, S, E> StateStoredAggregate.handle(command: C): S =\n    command\n        .fetchState()\n        .computeNewState(command)\n        .save()\n")))),(0,r.kt)("p",null,"Feel free to use these two extension modules, or create your own by using these two as a fine example."))}u.isMDXComponent=!0},5557:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/event-modeling-event-driven-systems-dd36561b4d665e5dfcc97acc8fccbf92.png"},6567:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/event-modeling-traditional-systems-1f8ef3235fa73ccc9ec41b05082804da.png"}}]);