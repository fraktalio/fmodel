"use strict";(self.webpackChunkfmodel=self.webpackChunkfmodel||[]).push([[957],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=u(n),p=r,h=c["".concat(s,".").concat(p)]||c[p]||m[p]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:r,o[1]=l;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294),r=n(6010);const i={tabItem:"tabItem_Ymn6"};function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i.tabItem,o),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>w});var a=n(7462),r=n(7294),i=n(6010),o=n(2466),l=n(6550),s=n(1980),u=n(7392),d=n(12);function c(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function m(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??c(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,l.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s._X)(i),(0,r.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(a.location.search);t.set(i,e),a.replace({...a.location,search:t.toString()})}),[i,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,i=m(e),[o,l]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[s,u]=h({queryString:n,groupId:a}),[c,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,i]=(0,d.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:a}),g=(()=>{const e=s??c;return p({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{g&&l(g)}),[g]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),f(e)}),[u,f,i]),tabValues:i}}var g=n(2389);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:t,block:n,selectedValue:l,selectValue:s,tabValues:u}=e;const d=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.o5)(),m=e=>{const t=e.currentTarget,n=d.indexOf(t),a=u[n].value;a!==l&&(c(t),s(a))},p=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const n=d.indexOf(e.currentTarget)+1;t=d[n]??d[0];break}case"ArrowLeft":{const n=d.indexOf(e.currentTarget)-1;t=d[n]??d[d.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:o}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>d.push(e),onKeyDown:p,onClick:m},o,{className:(0,i.Z)("tabs__item",v.tabItem,o?.className,{"tabs__item--active":l===t})}),n??t)})))}function y(e){let{lazy:t,children:n,selectedValue:a}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},i.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function k(e){const t=f(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",v.tabList)},r.createElement(b,(0,a.Z)({},e,t)),r.createElement(y,(0,a.Z)({},e,t)))}function w(e){const t=(0,g.Z)();return r.createElement(k,(0,a.Z)({key:String(t)},e))}},7470:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>u,toc:()=>c});var a=n(7462),r=(n(7294),n(3905)),i=n(4866),o=n(5162);const l={sidebar_position:3},s="Modeling the Behaviour",u={unversionedId:"domain/modeling-the-behaviour",id:"domain/modeling-the-behaviour",title:"Modeling the Behaviour",description:"- algebraic data types form the structure of our entities (commands, state, and events)",source:"@site/docs/domain/modeling-the-behaviour.md",sourceDirName:"domain",slug:"/domain/modeling-the-behaviour",permalink:"/fmodel/docs/domain/modeling-the-behaviour",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Structuring the data",permalink:"/fmodel/docs/domain/structuring-the-data"},next:{title:"Aggregating the Behaviour",permalink:"/fmodel/docs/domain/aggregating-the-behaviour"}},d={},c=[{value:"Decider",id:"decider",level:2},{value:"View",id:"view",level:2},{value:"Saga",id:"saga",level:2},{value:"Totality",id:"totality",level:2}],m={toc:c},p="wrapper";function h(e){let{components:t,...l}=e;return(0,r.kt)(p,(0,a.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"modeling-the-behaviour"},"Modeling the Behaviour"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"algebraic data types form the ",(0,r.kt)("inlineCode",{parentName:"li"},"structure")," of our entities (commands, state, and events)"),(0,r.kt)("li",{parentName:"ul"},"functions/lambda offers the algebra of manipulating the entities in a compositional manner, effectively modeling\nthe ",(0,r.kt)("inlineCode",{parentName:"li"},"behavior."))),(0,r.kt)("p",null,"This leads to modularity in design and a clear separation of the entity\u2019s structure and functions/",(0,r.kt)("inlineCode",{parentName:"p"},"behaviour")," of the\nentity."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Kotlin functions are first-class, which means they can be stored in variables and data structures, and can be passed as\narguments to and returned from other higher-order functions. Kotlin\nuses ",(0,r.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/lambdas.html#function-types"},"function types"),", such as ",(0,r.kt)("inlineCode",{parentName:"p"},"(Int) -> String"),", for\ndeclarations that deal with functions.")),(0,r.kt)("p",null,"Fmodel offers generic and abstract components to specialize in for your specific case/expected behavior:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Decider"),(0,r.kt)("li",{parentName:"ul"},"View"),(0,r.kt)("li",{parentName:"ul"},"Saga")),(0,r.kt)("h2",{id:"decider"},"Decider"),(0,r.kt)("p",null,"The decider is a data type that represents the main decision-making algorithm."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"initialState")," - A starting point / An initial state"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"decide")," (Exhaustive / pattern matching command handler) - A function/lambda that takes command and input state as\nparameters, and returns/emits the flow of output events"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"evolve")," (Exhaustive / pattern matching event-sourcing handler) - A function/lambda that takes input state and input\nevent as parameters, and returns the output/new state")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"decider image",src:n(7076).Z,width:"1998",height:"2021"})),(0,r.kt)(i.Z,{groupId:"concept",queryString:"concept",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"restaurant",label:"Restaurant",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'typealias RestaurantDecider = Decider<RestaurantCommand?, Restaurant?, RestaurantEvent?>\n\nfun restaurantDecider() = RestaurantDecider(\n    initialState = null,\n    decide = { c, s ->\n        when (c) {\n            is CreateRestaurantCommand ->\n                if (s == null) flowOf(RestaurantCreatedEvent(c.identifier, c.name, c.menu))\n                else flowOf(\n                    RestaurantNotCreatedEvent(\n                        c.identifier,\n                        c.name,\n                        c.menu,\n                        Reason("Restaurant already exists"),\n                        true\n                    )\n                )\n\n            is ChangeRestaurantMenuCommand ->\n                if (s == null) flowOf(\n                    RestaurantMenuNotChangedEvent(\n                        c.identifier,\n                        c.menu,\n                        Reason("Restaurant does not exist"),\n                    )\n                )\n                else flowOf(RestaurantMenuChangedEvent(c.identifier, c.menu))\n\n            is PlaceOrderCommand ->\n                if (s == null) flowOf(\n                    OrderNotPlacedAtRestaurantEvent(\n                        c.identifier,\n                        c.lineItems,\n                        c.orderIdentifier,\n                        Reason("Restaurant does not exist"),\n                    )\n                )\n                else if (!s.isValid(c)) flowOf(\n                    OrderRejectedByRestaurantEvent(\n                        c.identifier,\n                        c.orderIdentifier,\n                        Reason("Not on the menu"),\n                    )\n                )\n                else flowOf(\n                    OrderPlacedAtRestaurantEvent(c.identifier, c.lineItems, c.orderIdentifier)\n                )\n\n            null -> emptyFlow() // We ignore the `null` command by emitting the empty flow. Only the Decider that can handle `null` command can be combined (Monoid) with other Deciders.\n        }\n    },\n    evolve = { s, e ->\n        when (e) {\n            is RestaurantCreatedEvent -> Restaurant(e.identifier, e.name, e.menu)\n            is RestaurantMenuChangedEvent -> s?.copy(menu = e.menu)\n            is OrderPlacedAtRestaurantEvent -> s\n            is RestaurantErrorEvent -> s // Error events are not changing the state in our/this case.\n            null -> s // Null events are not changing the state / We return current state instead. Only the Decider that can handle `null` event can be combined (Monoid) with other Deciders.\n        }\n    }\n)\n\nprivate fun Restaurant.isValid(command: PlaceOrderCommand): Boolean =\n    (menu.menuItems.stream().map { mi -> mi.menuItemId }.collect(Collectors.toList())\n        .containsAll(command.lineItems.stream().map { li -> li.menuItemId }.collect(Collectors.toList())))\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Notice how the state of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Restaurant")," ",(0,r.kt)("a",{parentName:"p",href:"/fmodel/docs/domain/structuring-the-data#state"},"is modeled as a data class")))),(0,r.kt)(o.Z,{value:"order",label:"Order",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'typealias OrderDecider = Decider<OrderCommand?, Order?, OrderEvent?>\n\nfun orderDecider() = OrderDecider(\n    initialState = null,\n    decide = { c, s ->\n        when (c) {\n            is CreateOrderCommand ->\n                if (s == null) flowOf(OrderCreatedEvent(c.identifier, c.lineItems, c.restaurantIdentifier))\n                else flowOf(OrderRejectedEvent(c.identifier, Reason("Order already exists")))\n\n            is MarkOrderAsPreparedCommand ->\n                if (s == null) flowOf(OrderNotPreparedEvent(c.identifier, Reason("Order does not exist")))\n                else if (OrderStatus.CREATED != s.status) flowOf(\n                    OrderNotPreparedEvent(\n                        c.identifier,\n                        Reason("Order not in CREATED status"),\n                    )\n                )\n                else flowOf(OrderPreparedEvent(c.identifier))\n\n            null -> emptyFlow() // We ignore the `null` command by emitting the empty flow. Only the Decider that can handle `null` command can be combined (Monoid) with other Deciders.\n        }\n    },\n    evolve = { s, e ->\n        when (e) {\n            is OrderCreatedEvent -> Order(e.identifier, e.restaurantId, e.status, e.lineItems)\n            is OrderPreparedEvent -> s?.copy(status = e.status)\n            is OrderRejectedEvent -> s?.copy(status = e.status)\n            is OrderErrorEvent -> s // Error events are not changing the state in our/this case.\n            null -> s // Null events are not changing the state / We return current state instead. Only the Decider that can handle `null` event can be combined (Monoid) with other Deciders.\n        }\n    }\n)\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Notice how the state of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Order")," ",(0,r.kt)("a",{parentName:"p",href:"/fmodel/docs/domain/structuring-the-data#state"},"is modeled as a data class"))))),(0,r.kt)("h2",{id:"view"},"View"),(0,r.kt)("p",null,"The view is a data type that represents the event handling algorithm responsible for translating the events into the\ndenormalized state, which is adequate for querying."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"initialState")," - A starting point / An initial state"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"evolve")," (Exhaustive / pattern matching event handler) - A function/lambda that takes input state and input event as\nparameters, and returns the output/new state")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"view image",src:n(1283).Z,width:"1981",height:"1037"})),(0,r.kt)(i.Z,{groupId:"concept",queryString:"concept",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"restaurant",label:"Restaurant",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"typealias RestaurantView = View<RestaurantViewState?, RestaurantEvent?>\n\nfun restaurantView() = RestaurantView(\n    initialState = null,\n    evolve = { s, e ->\n        when (e) {\n            is RestaurantCreatedEvent -> RestaurantViewState(e.identifier, e.name, e.menu)\n            is RestaurantMenuChangedEvent -> s?.copy(menu = e.menu)\n            is OrderPlacedAtRestaurantEvent -> s\n            is RestaurantErrorEvent -> s // Error events are not changing the state in our/this case.\n            null -> s // Null events are not changing the state / We return current state instead. Only the Decider that can handle `null` event can be combined (Monoid) with other Deciders.\n        }\n    }\n)\n\ndata class RestaurantViewState(\n    val id: RestaurantId,\n    val name: RestaurantName,\n    val menu: RestaurantMenu\n)\n"))),(0,r.kt)(o.Z,{value:"order",label:"Order",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"typealias OrderView = View<OrderViewState?, OrderEvent?>\n\nfun orderView() = OrderView(\n    initialState = null,\n    evolve = { s, e ->\n        when (e) {\n            is OrderCreatedEvent -> OrderViewState(e.identifier, e.restaurantId, e.status, e.lineItems)\n            is OrderPreparedEvent -> s?.copy(status = e.status)\n            is OrderRejectedEvent -> s?.copy(status = e.status)\n            is OrderErrorEvent -> s // Error events are not changing the state in our/this case.\n            null -> s // Null events are not changing the state / We return current state instead. Only the Decider that can handle `null` event can be combined (Monoid) with other Deciders.\n        }\n    }\n)\n\ndata class OrderViewState(\n    val id: OrderId,\n    val restaurantId: RestaurantId,\n    val status: OrderStatus,\n    val lineItems: ImmutableList<OrderLineItem>\n)\n\n")))),(0,r.kt)("h2",{id:"saga"},"Saga"),(0,r.kt)("p",null,"Saga is a data type that represents the central point of control, deciding what to execute next. It is responsible for\nmapping different events from deciders into action results that the Saga then can use to calculate the subsequent\nactions to be\nmapped to the command of other deciders."),(0,r.kt)("p",null,"In the context of smart endpoints and dumb pipes, deciders would be smart endpoints, and saga would be a dumb pipe."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"react")," - A function/lambda that takes input action-result/event, and returns the flow of actions/commands that should\nbe published.")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"saga image",src:n(8490).Z,width:"1739",height:"852"})),(0,r.kt)(i.Z,{groupId:"concept",queryString:"concept",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"restaurant",label:"Restaurant",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"typealias RestaurantSaga = Saga<OrderEvent?, RestaurantCommand>\n\nfun restaurantSaga() = RestaurantSaga(\n    react = { e ->\n        when (e) {\n            is OrderCreatedEvent -> emptyFlow()\n            is OrderPreparedEvent -> emptyFlow()\n            is OrderErrorEvent -> emptyFlow()\n            null -> emptyFlow() // We ignore the `null` event by returning the empty flow of commands. Only the Saga that can handle `null` event/action-result can be combined (Monoid) with other Sagas.\n        }\n    }\n)\n\n"))),(0,r.kt)(o.Z,{value:"order",label:"Order",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"typealias OrderSaga = Saga<RestaurantEvent?, OrderCommand>\n\nfun orderSaga() = OrderSaga(\n    react = { e ->\n        when (e) {\n            is OrderPlacedAtRestaurantEvent -> flowOf(\n                CreateOrderCommand(\n                    e.orderId,\n                    e.identifier,\n                    e.lineItems\n                )\n            )\n\n            is RestaurantCreatedEvent -> emptyFlow()\n            is RestaurantMenuChangedEvent -> emptyFlow()\n            is RestaurantErrorEvent -> emptyFlow()\n            null -> emptyFlow() // We ignore the `null` event by returning the empty flow of commands. Only the Saga that can handle `null` event/action-result can be combined (Monoid) with other Sagas.\n        }\n    }\n)\n")))),(0,r.kt)("h2",{id:"totality"},"Totality"),(0,r.kt)("p",null,"A function is ",(0,r.kt)("inlineCode",{parentName:"p"},"total")," if it is defined for all of its possible inputs."),(0,r.kt)("p",null,"By having algebraic data types modeling the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sum/OR")," relationship with ",(0,r.kt)("inlineCode",{parentName:"p"},"sealed")," class, it's possible to verify that\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"when")," expression covers all cases, ",(0,r.kt)("strong",{parentName:"p"},"you don't need to add an ",(0,r.kt)("inlineCode",{parentName:"strong"},"else")," clause to the statement"),".\nThis is known as ",(0,r.kt)("inlineCode",{parentName:"p"},"Kotlin matching"),". Many modern languages have support for some kind of ",(0,r.kt)("inlineCode",{parentName:"p"},"pattern matching"),"."),(0,r.kt)("p",null,"The compiler will yell at you if you add a new command or event into the model/project (",(0,r.kt)("inlineCode",{parentName:"p"},"when")," expression goes red), and\nyou will have to fix it immediately.\nIt will positively influence the function (",(0,r.kt)("inlineCode",{parentName:"p"},"decide"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"evolve"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"react"),") totality giving more guarantees about code\ncorrectness."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The essence of functional programming lies in the power of pure functions. Add static types to the mix, and you have\nalgebraic abstractions\u2014functions operating on types and honoring certain laws. Make the functions generic on types, and\nyou have parametricity. The function becomes polymorphic, which implies more reusability, and if you\u2019re disciplined\nenough not to leak any implementation details by sneaking in specialized types (or unmanaged hazards such as\nexceptions), you get free theorems.")))}h.isMDXComponent=!0},7076:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/decider-kotlin-9415fd79342c0890d709918e2d65393e.png"},8490:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/saga-kotlin-4e4ad6019830547d050f6c0206464980.png"},1283:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/view-kotlin-ad25d74cc1579dc80a109d589b9e06dc.png"}}]);